## 字符编码

​		计算机中处理信息的最小单位是比特（bit，也称位），采用二进制表示。一个字节（byte）等于8个比特，所以，一个字节能表示的最大的**十进制整数**就是255（二进制11111111=十进制255），如果要表示更大的整数，就必须用更多的字节。比如两个字节可以表示的最大十进制整数是**65535**，4个字节可以表示的最大十进制整数是**4294967295**。

​		因为计算机只能处理数字，如果要处理文本，就必须先把文本中的字符（串）转换为数字才能处理。将字符映射成十进制或者二进制数字的过程被称为编码，而规定了具体编码规则的表被称为编码表。目前常用的编码表有**ASCII**编码、**Unicode**编码、**UTF-8**编码以及**GB2312**编码。

​		最早只有127个字符被编码到计算机里，也就是大小写英文字母、数字和一些符号，这个编码表被称为**ASCII**编码，比如大写字母**A**的编码是**65**，小写字母**z**的编码是**122**。

​	**ASCII**编码只包括了最早的127个字符，而不包括中文、韩文、日文等语言的字符。所以，为了把所有语言都统一到一套编码里，**Unicode**编码应运而生。

​		Unicode通常，也至少，是使用**两个字节**表示一个字符（如果要用到非常偏僻的字符，就需要4个字节）。ASCII编码只包括了最早的127个字符，因而只（需要）使用了**一个字节**进行编码。

​		如果统一成Unicode编码，乱码问题从此消失了。但是，如果你写的文本基本上全部是英文的话，用Unicode编码比ASCII编码需要多一倍的存储空间，在存储和传输上就十分不划算。所以，本着节约的精神，又出现了把Unicode编码转化为**“可变长编码”**的UTF-8编码。

​		UTF-8编码把一个Unicode字符根据不同的**十进制数字**大小编码成1-6个字节，常用的英文字母被编码成1个字节，汉字通常是3个字节，只有很生僻的字符才会被编码成4-6个字节。如果你要传输的文本包含大量英文字符，用UTF-8编码就能节省空间。此外，UTF-8编码有一个额外的好处，就是ASCII编码实际上可以被看成是UTF-8编码的一部分。**GB2312**编码是中国制定的，除了包括ASCII编码的内容外，还包括中文字符的编码规则。

下面用两个例子来说明不同编码的区别：

​		字母**A**用ASCII编码是十进制的**65**，二进制的**01000001**；而用Unicode编码字母A，十进制同样是**65**，而因为Unicode编码通常至少两个字节，因而用其对字符A进行二进制编码，需要在ASCII编码的二进制数字前面补0，因此，A的Unicode编码是**00000000 01000001**。汉字**中**不能用ASCII进行编码，因为已经超出了其编码的范围；用Unicode编码是十进制的**20013**，二进制的**01001110 00101101**；用UTF-8编码得到的十进制数字是**14989485**，二进制**11100100 10111000 10101101**。

| 字符 | Unicode编码十进制 | Unicode编码二进制 | UTF-8十进制 |        UTF-8二进制         |
| :--: | :---------------: | :---------------: | :---------: | :------------------------: |
|  A   |        65         | 00000000 01000001 |     65      |          01000001          |
|  中  |       20013       | 01001110 00101101 |  14989485   | 11100100 10111000 10101101 |

​		**综上可以得知，同一个字符，用不同的编码表编码，所得到的十进制数字和二进制数字会不尽相同**。ASCII编码中包括的127个字符，用不同的编码表编码时，所得到的十进制数字是相同的，但其二进制数字表示会因为占用的字节数不同而不同；而对于中、日、韩等语言所包括的ASCII编码所不包括的字符，用不同的编码表编码时，所得到的无论是十进制数字和还是二进制数字都有所不同。



​		需要注意的是，在计算机内存中，统一使用Unicode编码，当需要保存到硬盘或者需要传输的时候，就转换为UTF-8编码。因而，当你用记事本编辑的时候，从文件读取的UTF-8字符会被转换为Unicode字符到内存里，编辑完成后，保存的时候再把Unicode转换为UTF-8保存到文件：

![rw-file-utf-8](https://www.liaoxuefeng.com/files/attachments/923923787018816/0)



浏览网页的时候，服务器会把内存中动态生成的Unicode内容转换为UTF-8再传输到浏览器：



![web-utf-8](https://www.liaoxuefeng.com/files/attachments/923923759189600/0)







# python字符串

## 字符串操作

（1）字符串'xxx'也可以看成是一种list，每个元素就是一个字符。因此，字符串也可以用切片操作，只是操作结果仍是**字符串**。**字符串相加，拼接后依然是字符串**。

```python
s1 = 'ABCDEFG'[::2]
print(s1) #'ACEG'
s2 = [m + n for m in 'ABC' for n in 'XYZ']
print(s2) # ['AX', 'AY', 'AZ', 'BX', 'BY', 'BZ', 'CX', 'CY', 'CZ']
```



## 字符串格式化

（1）在Python中，其中一种格式化方式和C语言是一致的，用**%运算符**实现。在字符串内部，%s表示用字符串替换，%d表示用整数替换，有几个%?占位符，后面就跟几个变量或者值，顺序要对应好，且**中间是用空格而不是逗号隔开**。有多个%?站位符时，后面需要**用括号把变量或者值括起来，如果只有一个%?，括号可以省略**。

| 占位符 |   替换内容   |
| :----: | :----------: |
|   %d   |     整数     |
|   %f   |    浮点数    |
|   %s   |    字符串    |
|   %x   | 十六进制整数 |

```python
s1 = 'Hello, %s' % 'world'
s2 = 'Hi, %s, you have $%d.' % ('Michael', 1000000)

print(s1,s) #'Hello, world' 'Hi, Michael, you have $1000000.' 
```

（2）格式化整数和浮点数还可以指定是否补0和整数与小数的位数。

```python
s3 = '%2d-%02d' % (3, 1)
s4 = '%.2f' % 3.1415926

print(s3,s4,s5) #3-01 3.14 
```

（3）如果你不太确定应该用什么，`%s`永远起作用，它会把任何数据类型转换为字符串。用%%来表示一个普通字符%。

```python
s5 = 'Age: %s. Gender: %s' % (25, True)
s6 = 'growth rate: %d %%' % 7

print(s5, s6) # 'Age: 25. Gender: True' 'growth rate: 7 %'
```

（4）python另一种格式化字符串的方法是使用字符串的**format()**方法，它会用传入的参数依次替换字符串内的占位符{0}、{1}…….。这种方式写起来比%?占位符方式要麻烦一些，但**不需要区分参数的具体类型**。

```python
s7 = 'Hello, {0}, 成绩提升了 {1:.1f}%'.format('小明', 17.125)

print(s7) #'Hello, 小明, 成绩提升了 17.1%'
```



## 字符串的编码和解码

（1）Python提供了**ord()**函数获取单个字符的十进制整数表示，而**chr()**函数则是把十进制整数转换为对应的字符：

```python
a = ord('A')
b = ord('中')
c = chr(66)
d = chr(25991)
print(a,b,c,d) # 65 20013 B 文 
```

（2）由于Python的字符串类型是str，在内存中以**Unicode**表示，一个字符对应若干个字节。如果要在网络上传输，或者保存到磁盘上，就需要把str变为以字节为单位的bytes。Python对bytes类型的数据用带**b**前缀的单引号或双引号表示。

```python
x = b'ABC'
```

要注意区分'ABC'和b'ABC'，前者是**str**，后者是**bytes**。

（3）python中**len()**函数计算的是str的**字符数**，如果换成bytes，len()函数就计算**字节数**。**bytes**的每个字符都只占用一个字节（bytes是以b'\x'分割各个字符）：

```python
l1 = len('ABC')
l2 = len(b'ABC')
l3 = len('中文')
l4 = len(b'\xe4\xb8\xad\xe6\x96\x87') # b'\xe4\xb8\xad\xe6\x96\x87'是字符串'中文'的字节表示
print(l1,l2,l3,l4)  # 3 3 2 6
```

可以从上知道，1个中文字符经过UTF-8编码后通常会占用3个字节，而1个英文字符只占用1个字节

（4）以Unicode表示的str通过**encode()**方法可以编码为指定的bytes，同样通过**decode()**方法可以将字节bytes解码为str：

```python
b1 = 'ABC'.encode('utf-8')
b2 = '中文'.encode('utf-8')
s1 = b'ABC'.decode('utf-8')
s2 = b'\xe4\xb8\xad\xe6\x96\x87'.decode('utf-8')
print(b1,b2,s1,s2) # b'ABC' b'\xe4\xb8\xad\xe6\x96\x87' ABC 中文
```

（5）利用**encode()**和**decode()**进行编码和解码时，要注意编码类别，不能超出编码的范围。比如，纯英文str可以用用ASCII编码，但含有中文的str无法用ASCII编码，因为中文编码的范围超过了ASCII编码的范围，Python会报错；反过来，如果bytes中包含无法解码的字节，decode()方法同样会报错。例如，下面代码中第三行和第四行代码会报错。

```python
'中文'.encode('utf-8') # b'\xe4\xb8\xad\xe6\x96\x87'
b'\xe4\xb8\xad\xe6\x96\x87'.decode('utf-8') # 中文
'中文'.encode('ascii')
b'\xe4\xb8\xad\xe6\x96\x87'.decode('ascii') 
```

（6）但如果bytes中只有一小部分无效的字节，可以传入errors='ignore'忽略错误的字节。下面代码中，第一行会报错，但第二行不会。在操作字符串时，我们经常遇到str和bytes的互相转换。为了避免乱码问题，应当始终坚持使用UTF-8编码对str和bytes进行转换。

```python
b'\xe4\xb8\xad\xff'.decode('utf-8')
b'\xe4\xb8\xad\xff'.decode('utf-8', errors='ignore') # 中
```

（7）由于Python源代码也是一个文本文件，所以，当你的源代码中包含中文的时候，在保存源代码时，就需要务必指定保存为UTF-8编码。当Python解释器读取源代码时，为了让它按UTF-8编码读取，我们通常在文件开头写一行：

```python
# -*- coding: utf-8 -*-
```



（8）**lower()**将字符串中的大些英文字母转化为小写（只转大写英文，其他不管）、upper()和title()函数